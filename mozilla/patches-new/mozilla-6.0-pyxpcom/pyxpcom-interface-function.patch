# HG changeset patch
# Date 1318029799 25200
# User Mook <marky@activestate.com>
# Parent d60e4e3025a370b6075e798950427d7a6cfa4ca5
pyxpcom: allow callables for interfaces marked as [function]

diff --git a/xpcom/server/policy.py b/xpcom/server/policy.py
--- a/xpcom/server/policy.py
+++ b/xpcom/server/policy.py
@@ -55,50 +55,75 @@ VARIANT_INT_TYPES = xpcom_consts.VTYPE_I
 VARIANT_LONG_TYPES = xpcom_consts.VTYPE_INT64, xpcom_consts.VTYPE_UINT64
 VARIANT_FLOAT_TYPES = xpcom_consts.VTYPE_FLOAT, xpcom_consts.VTYPE_DOUBLE
 VARIANT_STRING_TYPES = xpcom_consts.VTYPE_CHAR, xpcom_consts.VTYPE_CHAR_STR, xpcom_consts.VTYPE_STRING_SIZE_IS, \
                        xpcom_consts.VTYPE_CSTRING
 VARIANT_UNICODE_TYPES = xpcom_consts.VTYPE_WCHAR, xpcom_consts.VTYPE_DOMSTRING, xpcom_consts.VTYPE_WSTRING_SIZE_IS, \
                         xpcom_consts.VTYPE_ASTRING 
 
 _supports_primitives_map_ = {} # Filled on first use.
+_function_interfaces_ = [] # Filled on first use
 
 _interface_sequence_types_ = types.TupleType, types.ListType
 _string_types_ = types.StringType, types.UnicodeType
 XPTI_GetInterfaceInfoManager = _xpcom.XPTI_GetInterfaceInfoManager
 
 def _GetNominatedInterfaces(obj):
+    iim = XPTI_GetInterfaceInfoManager()
+
+    real_ret = set()
     ret = getattr(obj, "_com_interfaces_", None)
-    if ret is None: return None
+    if ret is None:
+        if type(obj) == types.FunctionType:
+            # we got a function, try [function]s
+            global _function_interfaces_
+            if not _function_interfaces_:
+                enum = iim.enumerateInterfaces()
+                while not enum.IsDone():
+                    interface_info = enum.CurrentItem(xpcom._xpcom.IID_nsIInterfaceInfo)
+                    enum.Next()
+                    try:
+                        if interface_info.isFunction():
+                            real_ret.add(interface_info.GetIID())
+                            assert interface_info.GetParent().GetIID() == IID_nsISupports
+                    except COMException, e:
+                        # this can happen if the interface failed to resolve.
+                        if e.errno != nsError.NS_ERROR_UNEXPECTED:
+                            raise
+                        logger.warning("Warning: failed to inspect interface %s for [function] flag",
+                                       interface_info.name)
+                _function_interfaces_ = list(real_ret)
+            return _function_interfaces_
+        return None
+
     # See if the user only gave one.
     if type(ret) not in _interface_sequence_types_:
         ret = [ret]
-    real_ret = []
+
     # For each interface, walk to the root of the interface tree.
-    iim = XPTI_GetInterfaceInfoManager()
     for interface in ret:
         # Allow interface name or IID.
         interface_info = None
         if type(interface) in _string_types_:
             try:
                 interface_info = iim.GetInfoForName(interface)
             except COMException:
                 pass
         if interface_info is None:
             # Allow a real IID
             interface_info = iim.GetInfoForIID(interface)
-        real_ret.append(interface_info.GetIID())
+        real_ret.add(interface_info.GetIID())
         parent = interface_info.GetParent()
         while parent is not None:
             parent_iid = parent.GetIID()
             if parent_iid == IID_nsISupports:
                 break
-            real_ret.append(parent_iid)
+            real_ret.add(parent_iid)
             parent = parent.GetParent()
-    return real_ret
+    return list(real_ret)
 
 ##
 ## ClassInfo support
 ##
 ## We cache class infos by class
 class_info_cache = {}
 
 def GetClassInfoForObject(ob):
@@ -136,16 +161,17 @@ class DefaultClassInfo:
     def getHelperForLanguage(self, language):
         return None # Not sure what to do here.
 
 class DefaultPolicy:
     def __init__(self, instance, iid):
         self._obj_ = instance
         self._nominated_interfaces_ = ni = _GetNominatedInterfaces(instance)
         self._iid_ = iid
+        self._is_function_ = None # looked up lazily in _CallMethod_
         if ni is None:
             raise ValueError, "The object '%r' can not be used as a COM object" % (instance,)
         # This is really only a check for the user - the same thing is
         # done by the framework.
         # XXXmarkh - this should probably die now we have better error
         # reporting in the framework!
         if __debug__:
             if iid != IID_nsISupports and iid not in ni:
@@ -266,20 +292,27 @@ class DefaultPolicy:
             # Look for a function of that name
             func = getattr(self._obj_, "set_" + name, None)
             if func is None:
                 assert len(param_descs)==1 and len(params)==1, "Can only handle a single [in] arg for a default setter"
                 setattr(self._obj_, name, params[0]) # Let attribute error go here!
             else:
                 func(*params)
             return 0
-        else:
-            # A regular method.
-            func = getattr(self._obj_, name)
-            return 0, func(*params)
+        elif callable(self._obj_):
+            if self._is_function_ is None:
+                iim = _xpcom.XPTI_GetInterfaceInfoManager()
+                interface_info = iim.GetInfoForIID(self._iid_)
+                self._is_function_ = interface_info.GetIsFunction()
+            if self._is_function_:
+                return 0, self._obj_(*params)
+
+        # A regular method.
+        func = getattr(self._obj_, name)
+        return 0, func(*params)
 
     def _doHandleException(self, func_name, exc_info):
         exc_val = exc_info[1]
         is_server_exception = isinstance(exc_val, ServerException)
         if is_server_exception:
             # When a component raised an explicit COM exception, it is
             # considered 'normal' - however, we still write a debug log
             # record to help track these otherwise silent exceptions.
diff --git a/xpcom/src/PyIInterfaceInfo.cpp b/xpcom/src/PyIInterfaceInfo.cpp
--- a/xpcom/src/PyIInterfaceInfo.cpp
+++ b/xpcom/src/PyIInterfaceInfo.cpp
@@ -385,16 +385,35 @@ static PyObject *PyGetInterfaceIsArgNumb
         PRUint8 ret;
 	const nsXPTParamInfo& param_info = pmi->GetParam((PRUint8)pi);
 	nsresult n = pii->GetInterfaceIsArgNumberForParam(mi, &param_info, &ret);
 	if (NS_FAILED(n))
 		return PyXPCOM_BuildPyException(n);
 	return PyInt_FromLong(ret);
 }
 
+static PyObject *PyGetIsFunction(PyObject *self, PyObject *args)
+{
+	if (args && !PyArg_ParseTuple(args, ":GetIsFunction"))
+		return NULL;
+
+	nsIInterfaceInfo *pI = GetI(self);
+	if (pI==NULL)
+		return NULL;
+
+	PRBool isFunction;
+	nsresult r;
+	Py_BEGIN_ALLOW_THREADS;
+	r = pI->IsFunction(&isFunction);
+	Py_END_ALLOW_THREADS;
+	if ( NS_FAILED(r) )
+		return PyXPCOM_BuildPyException(r);
+	return PyBool_FromLong(isFunction);
+}
+
 struct PyMethodDef 
 PyMethods_IInterfaceInfo[] =
 {
 	{ "GetName", PyGetName, 1},
 	{ "GetIID", PyGetIID, 1},
 	{ "IsScriptable", PyIsScriptable, 1},
 	{ "GetParent", PyGetParent, 1},
 	{ "GetMethodCount", PyGetMethodCount, 1},
@@ -403,16 +422,17 @@ PyMethods_IInterfaceInfo[] =
 	{ "GetMethodInfoForName", PyGetMethodInfoForName, 1},
 	{ "GetConstant", PyGetConstant, 1},
 	{ "GetInfoForParam", PyGetInfoForParam, 1},
 	{ "GetIIDForParam", PyGetIIDForParam, 1},
 	{ "GetTypeForParam", PyGetTypeForParam, 1},
 	{ "GetSizeIsArgNumberForParam", PyGetSizeIsArgNumberForParam, 1},
 	{ "GetLengthIsArgNumberForParam", PyGetLengthIsArgNumberForParam, 1},
 	{ "GetInterfaceIsArgNumberForParam", PyGetInterfaceIsArgNumberForParam, 1},
+	{ "GetIsFunction", PyGetIsFunction, METH_NOARGS},
 	{NULL}
 };
 
 /*
   NS_IMETHOD GetMethodInfo(PRUint16 index, const nsXPTMethodInfo * *info) = 0;
   NS_IMETHOD GetMethodInfoForName(const char *methodName, PRUint16 *index, const nsXPTMethodInfo * *info) = 0;
   NS_IMETHOD GetConstant(PRUint16 index, const nsXPTConstant * *constant) = 0;
   NS_IMETHOD GetInfoForParam(PRUint16 methodIndex, const nsXPTParamInfo * param, nsIInterfaceInfo **_retval) = 0;
diff --git a/xpcom/xpcom_consts.py b/xpcom/xpcom_consts.py
--- a/xpcom/xpcom_consts.py
+++ b/xpcom/xpcom_consts.py
@@ -175,21 +175,23 @@ XPT_TDP_FLAGMASK         = 0xe0
 XPT_TDP_TAGMASK          = (~XPT_TDP_FLAGMASK)
 def XPT_TDP_TAG(tdp): return (tdp & XPT_TDP_TAGMASK)
 
 def XPT_TDP_IS_POINTER(flags): return (flags & XPT_TDP_POINTER)
 def XPT_TDP_IS_UNIQUE_POINTER(flags): return (flags & XPT_TDP_UNIQUE_POINTER)
 def XPT_TDP_IS_REFERENCE(flags): return (flags & XPT_TDP_REFERENCE)
 
 XPT_ID_SCRIPTABLE           = 0x80
-XPT_ID_FLAGMASK             = 0x80
+XPT_ID_FUNCTION             = 0x40
+XPT_ID_FLAGMASK             = 0xc0
 XPT_ID_TAGMASK              = ~XPT_ID_FLAGMASK
 def XPT_ID_TAG(id): return id & XPT_ID_TAGMASK
 
 def XPT_ID_IS_SCRIPTABLE(flags): return flags & XPT_ID_SCRIPTABLE
+def XPT_ID_IS_FUNCTION(flags): return flags & XPT_ID_FUNCTION
 
 XPT_PD_IN       = 0x80
 XPT_PD_OUT      = 0x40
 XPT_PD_RETVAL   = 0x20
 XPT_PD_SHARED   = 0x10
 XPT_PD_DIPPER   = 0x08
 XPT_PD_OPTIONAL = 0x04
 XPT_PD_FLAGMASK = 0xf0
