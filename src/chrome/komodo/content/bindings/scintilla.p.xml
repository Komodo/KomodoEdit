<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
 Version: MPL 1.1/GPL 2.0/LGPL 2.1
 
 The contents of this file are subject to the Mozilla Public License
 Version 1.1 (the "License"); you may not use this file except in
 compliance with the License. You may obtain a copy of the License at
 http://www.mozilla.org/MPL/
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 License for the specific language governing rights and limitations
 under the License.
 
 The Original Code is Komodo code.
 
 The Initial Developer of the Original Code is ActiveState Software Inc.
 Portions created by ActiveState Software Inc are Copyright (C) 2000-2007
 ActiveState Software Inc. All Rights Reserved.
 
 Contributor(s):
   ActiveState Software Inc
 
 Alternatively, the contents of this file may be used under the terms of
 either the GNU General Public License Version 2 or later (the "GPL"), or
 the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 in which case the provisions of the GPL or the LGPL are applicable instead
 of those above. If you wish to allow use of your version of this file only
 under the terms of either the GPL or the LGPL, and not to allow others to
 use your version of this file under the terms of the MPL, indicate your
 decision by deleting the provisions above and replace them with the notice
 and other provisions required by the GPL or the LGPL. If you do not delete
 the provisions above, a recipient may use your version of this file under
 the terms of any one of the MPL, the GPL or the LGPL.
 
 ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl">

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <!--
    NOTES:
    scintilla requires functions from:
    chrome://komodo/content/library/color_functions.js
    -->
    <binding id="scintilla">
        <content>
<!-- #if PLATFORM == "win" -->
            <html:embed type="application/x-scimoz-plugin"
                        xbl:inherits="flex,width,height"
                        anonid="scimoz"
                        flex="1"
                        width="0" height="0"
                        pluginHandlesDomEvents="false"
                        />
<!-- #elif PLATFORM == "linux" -->
            <html:embed type="application/x-scimoz-plugin"
                        xbl:inherits="flex,width,height"
                        anonid="scimoz"
                        flex="1"
                        width="100%" height="100%"
                        pluginHandlesDomEvents="false"
                        />
<!-- #elif PLATFORM == "darwin" -->
            <html:embed type="application/x-scimoz-plugin"
                        xbl:inherits="flex,width,height"
                        anonid="scimoz"
                        flex="1"
                        width="100%" height="100%"
                        pluginHandlesDomEvents="true"
                        pluginHandlesDragEvents="false"
                        />
<!-- #endif -->
        </content>
        <implementation implements="nsIObserver">
            <field name='_inMouseDown'>-1</field>

            <!-- x,y coord list containing position initiating a drag or null -->
            <field name='_startDragDrop'>null</field> 
            <property name="inDragDrop" onget="return this._startDragDrop != null;"/>

            <!-- x,y list of mousedown or mousemove, or null, used in blur -->
            <field name='_lastMousePos'>null</field> 

            <!-- key_handler: Javascript function which gets first dibs on
                              keypressed events. Function gets called in
                              the "keypress" event handler below. -->
            <!-- Currently used for:
                    * interactive search
                    * raw key handling
                    * repeat next keypress N times
                 Note1: This will override all keypress events to scintilla,
                        so commands (including vi) will not work whilst this
                        field is set.
                 Note2: View bindings that inherit this class and override the
                        "keypress" event handler, should ensure they don't break
                        this functionality.
            -->
            <field name="key_handler">null</field>
            <!-- mouse_handler: Javascript function which gets first dibs on mouse events -->
            <field name="mouse_handler">null</field>
            <field name='_mozcontext'>null</field>
            <field name='_contextShowing'>false</field>

            <field name='symbolMargin'>true</field>
<!-- #if PLATFORM != "darwin" -->
            <!-- Alt-key handling needs special care to avoid its default
                (focusing the menu) when using `Alt+click/drag` for
                block/rectangular-selection via the mouse.
                `needToStopAltPropagation` is set to true if `Alt+click/drag`
                is detected, then used and reset by a `keyup` handler for Alt.
                -->
            <field name='needToStopAltPropagation'>false</field>
            <field name='_dragScrollHits'>1</field>
<!-- #endif -->

            <!--nsIObserver implementation-->
            <method name="observe">
            <parameter name="subject"/>
            <parameter name="topic"/>
            <parameter name="data"/>
            <body>
            <![CDATA[
            try {
                //     dump('got ' + topic + ', subject = ' + subject + ', data = ' + data + '\n');
                // we're only concerned with global prefs here
                var prefs = Components.classes['@activestate.com/koPrefService;1'].
                                        getService(Components.interfaces.koIPrefService).prefs;
                switch (topic) {
                    case 'editor-scheme': // pref notification
                        // Get the scheme from the scheme service
                        try {
                            var schemeService = Components.classes['@activestate.com/koScintillaSchemeService;1'].getService();
                        } catch (e) {
                            // This means we're in shutdown mode -- just ignore it and return
                            return;
                        }
                        var schemeName = prefs.getStringPref('editor-scheme');
                        // dump('got schemename in observer ' + schemeName + '\n');
                        this.scheme = schemeService.getScheme(schemeName);
                        break;
                    case 'scheme-changed':
                        // dump("applying scheme\n");
                        if (this.inited) {
                            this.scheme.applyScheme(this.scimoz, this.language, this.encoding, this.alternateFaceType);
                        }
                        break;
                    case 'scrollEndAtLastLine': // pref notification
                        // XXX this doesn't seem to work right
                        this.scimoz.endAtLastLine = prefs.getBooleanPref('scrollEndAtLastLine');
                        break;
                };
            } catch (e) {
                this.log.exception(e);
            }
            ]]>
            </body>
            </method>

            <field name="_scimoz">null</field>
            <property name="xscimoz" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'scimoz').ISciMoz;"/>
            <property name="scimoz">
                <getter><![CDATA[
                if (this._scimoz == null) {
                    var xblContent = document.getAnonymousElementByAttribute(this, 'anonid', 'scimoz');
                    this._scimoz = xblContent && xblContent.ISciMoz;
                }
                return this._scimoz;
                ]]></getter>
            </property>

            <field name="_log">null</field>
            <property name="log">
                <getter><![CDATA[
                if (!this._log)
                    this._log = ko.logging.getLogger('scintilla');
                return this._log;
                ]]></getter>
            </property>

            <field name="_scheme">null</field>
            <property name="scheme">
                <setter><![CDATA[
                    this._scheme = val;
                    // dump("applying scheme!\n");
                    if (this.inited) {
                        this._scheme.applyScheme(this.scimoz, this.language, this.encoding, this.alternateFaceType);
                    }
                ]]>
                </setter>
                <getter><![CDATA[
                    if (! this._scheme) {
                        // Get the scheme from the scheme service
                        var prefs = Components.classes['@activestate.com/koPrefService;1'].
                                        getService(Components.interfaces.koIPrefService).prefs;
                        var obsvc = Components.classes['@mozilla.org/observer-service;1'].
                                getService(Components.interfaces.nsIObserverService);                        // Get the scheme from the scheme service
                        var schemeService = Components.classes['@activestate.com/koScintillaSchemeService;1'].getService();
                        obsvc.addObserver(this, "scheme-changed",false);
                        var schemeName = prefs.getStringPref('editor-scheme');
                        // dump("using schemeName = "+ schemeName+'\n');
                        this._scheme = schemeService.getScheme(schemeName);
                    }
                    return this._scheme;
                ]]>
                </getter>
            </property>

            <field name="inited">false</field> <!--Set to true once initialization complete.-->

            <field name="_language">Text</field>
            <property name="language">
                <getter><![CDATA[
                    return this._language;
                ]]></getter>
                <setter><![CDATA[
                    var old = this._language;
                    this._language = val;
                    if (old != val && this.inited) {
                        this.scheme.applyScheme(this.scimoz, this._language, this.encoding, this.alternateFaceType);
                    } // Otherwise we'll let init do it;
                ]]></setter>
            </property>

            <field name="_encoding">null</field>
            <property name="encoding">
                <getter><![CDATA[
                    if (!this._encoding) {
                        this._encoding = 'default';
                    }
                    return this._encoding;
                ]]></getter>
                <setter><![CDATA[
                    var old = this._encoding;
                    this._encoding = val;
                    if (old != val && this.inited) {
                        this.scheme.applyScheme(this.scimoz, this.language, this._encoding, this.alternateFaceType);
                    }
                ]]></setter>
            </property>

            <field name="_alternateFaceType">false</field>
            <property name="alternateFaceType">
                <getter><![CDATA[
                    return this._alternateFaceType;
                ]]></getter>
                <setter><![CDATA[
                    var old = this._alternateFaceType;
                    if (old != val) {
                        this._alternateFaceType = val;
                        if (this.inited) {
                            this.scheme.applyScheme(this.scimoz, this.language,
                                this.encoding, this._alternateFaceType);
                        }
                    }
                ]]></setter>
            </property>

            <field name="DECORATOR_SOFT_CHAR">Components.interfaces.koILintResult.DECORATOR_SOFT_CHAR</field>
            <field name="bracketedDecoratedChars">null</field>
            <field name="inLinkedTabstop">false</field>

            <destructor>
            <![CDATA[
            this.unload();
            ]]>
            </destructor>

            <method name="init">
                <body>
                <![CDATA[
            try {
                this.log.debug('scintilla init');
                var prefs = Components.classes['@activestate.com/koPrefService;1'].
                                getService(Components.interfaces.koIPrefService).prefs;
                // NOTE: This method is really a helper - if you want more
                // control, you can do all this yourself!
                var scimoz = this.scimoz;
                try {
                    var controller = Components.classes['@ActiveState.com/scintilla/controller;1'].createInstance().QueryInterface(Components.interfaces.ISciMozController);
                    controller.init( scimoz );
                    controller = controller.QueryInterface(Components.interfaces.nsIController);
                    this.controllers.appendController(controller);
                    scimoz.setCommandUpdateTarget(window);
                } catch(e) {
                    this.log.exception(e);
                }
                var context = this.getAttribute('mozcontext');
                if (context)
                    this._mozcontext = document.getElementById(context);
                if (this._mozcontext || this.getAttribute('context')) {
                    scimoz.usePopUp(0);
                }

                // mouseDownCaptures must be true, otherwise, when
                // selecting text with the mouse, if you go outside
                // the scimoz plugin and release the mouse button,
                // scintilla will not know and continue to track the
                // mouse position as if you had not released the mouse
                // button.
                // XXX unfortunately, this causes other mouse problems,
                // so we'll keep one bug until we figure it out.
<!-- #if PLATFORM == "darwin" or PLATFORM == "win" -->
                scimoz.mouseDownCaptures = 1;
<!-- #else -->
                scimoz.mouseDownCaptures = 0;
<!-- #endif -->
                scimoz.mouseDwellTime = 500;
                scimoz.indent = 4;
                scimoz.tabWidth = 8;
                scimoz.setProperty('smartCloseTags', '1');
                scimoz.wrapVisualFlags = prefs.getLongPref("editWordWrapMarker");
                // XXX this allows us to scroll the last line to the top of the
                // view of the buffer. Not sure if we will keep this in, or
                // perhaps make it a pref
                prefs.prefObserverService.addObserver(this, 'scrollEndAtLastLine', false);
                if (prefs.getBooleanPref("scrollEndAtLastLine"))
                    scimoz.endAtLastLine = false;

<!-- #if PLATFORM == "win" -->
                scimoz.eOLMode = scimoz.SC_EOL_CRLF;
<!-- #else -->
                scimoz.eOLMode = scimoz.SC_EOL_LF;
<!-- #endif -->
                scimoz.codePage = 65001;

                const SC_MOD_WANTED = scimoz.SC_MOD_CHANGESTYLE |
                      scimoz.SC_MOD_INSERTTEXT | scimoz.SC_MOD_DELETETEXT |
                      scimoz.SC_MOD_BEFOREDELETE | scimoz.SC_MOD_BEFOREINSERT;

                // Don't let scintilla send us every single event it fires, these are the
                // only ones we care about.
                scimoz.modEventMask = SC_MOD_WANTED;

                // Don't feel the need to make this a pref yet.
                scimoz.setXCaretPolicy(scimoz.CARET_SLOP, 75);

                // Setup margins and markers.
                // - margin 0: line numbers
                // - margin 1: folding (controlled by Python code,
                //             koDocumentSettingsManager)
                // - margin 2: symbols (iff this.symbolMargin)
                var symbolMarginMask = ko.markers.setup(scimoz);
                scimoz.setMarginTypeN(0, scimoz.SC_MARGIN_NUMBER);
                scimoz.setMarginWidthN(1, 0);
                if (this.symbolMargin) {
                    scimoz.setMarginTypeN(2, scimoz.SC_MARGIN_SYMBOL);
                    scimoz.setMarginMaskN(2, symbolMarginMask);
                    scimoz.setMarginSensitiveN(2, 1);
                    scimoz.setMarginWidthN(2, 16);
                } else {
                    scimoz.setMarginWidthN(2, 0);
                }

                // Allow column editing through Scintilla.
                scimoz.multipleSelection = false;
                scimoz.additionalSelectionTyping = true;
                // This allows a rectangular selection to extend past the
                // end of the line when there is a longer selected line.
                scimoz.virtualSpaceOptions = scimoz.SCVS_RECTANGULARSELECTION;
                // This allows Scintilla to perform indenting/dedenting when
                // there is a rectangular selection.
                scimoz.tabIndents = true;

                this.scheme.applyScheme(scimoz, this.language, this.encoding, this.alternateFaceType); // Shouldn't do these for editor views?
                this.inited = true;
                prefs.prefObserverService.addObserver(this, 'editor-scheme', false);
                scimoz.visible = true;
            } catch (e) {
                this.log.exception(e);
            }
                ]]>
                </body>
            </method>

            <method name="unload">
            <body><![CDATA[
                if (!this.inited) {
                    return;
                }
                try {
                    var prefs = Components.classes['@activestate.com/koPrefService;1'].
                                    getService(Components.interfaces.koIPrefService).prefs;
                    prefs.prefObserverService.removeObserver(this, 'editor-scheme');
                    prefs.prefObserverService.removeObserver(this, 'scrollEndAtLastLine');
                } catch (e) {
                    this.log.debug('pref observer service gone already');
                }
                try {
                    var obsvc = Components.classes['@mozilla.org/observer-service;1'].
                                    getService(Components.interfaces.nsIObserverService);
                    obsvc.removeObserver(this, "scheme-changed");
                } catch (e) {
                    this.log.debug('observer service gone already');
                }
                try {
                    this.scimoz.setCommandUpdateTarget(null);
                } catch (e) {
                    this.log.warn("Scintilla ["+this.id+"] was gone before we unloaded!");
                }
                this.inited = false;
                // Mark scimoz as closed, which will ensure no more calls are
                // made to this instance. Bug 81293.
                // Note: There should be no more calls to scimoz after this!
                this.scimoz.markClosed();
                this._scimoz = null;
            ]]></body>
            </method>

            <method name="getSupportedFlavours">
                <body>
                <![CDATA[
                var flavours = new FlavourSet();
                flavours.appendFlavour("application/x-komodo-snippet");
                flavours.appendFlavour("application/x-moz-file", "nsIFile");
                flavours.appendFlavour("text/unicode");
<!-- #if PLATFORM != "win" -->
                flavours.appendFlavour("TEXT");
<!-- #endif -->
                return flavours;
                ]]>
                </body>
            </method>

            <method name="canUndo">
                <body>
                <![CDATA[
                    return this.scimoz.canUndo();
                ]]>
                </body>
            </method>
            <method name="canRedo">
                <body>
                <![CDATA[
                    return this.scimoz.canRedo();
                ]]>
                </body>
            </method>

            <method name="setFoldStyle">
                <parameter name="whichMargin"/>
                <parameter name="foldstyle"/>
                <body><![CDATA[
                    var scimoz = this.scimoz;
                    scimoz.setMarginTypeN(whichMargin, scimoz.SC_MARGIN_SYMBOL);
                    scimoz.setMarginSensitiveN(whichMargin, whichMargin);
                    switch (foldstyle) {
                        case 'none':
                            scimoz.showLines(0, scimoz.lineCount-1);
                            for (line = 0; line < scimoz.lineCount; line++) {
                                if (scimoz.getFoldLevel(line) &
                                    scimoz.SC_FOLDLEVELHEADERFLAG) {
                                    scimoz.setFoldExpanded(line, 1);
                                }
                            }
                            // If we don't do this, folding trails off
                            // into other buffers.
                            scimoz.setProperty("fold", "0");
                            scimoz.setMarginWidthN(1, 0);
                            break;
                        case 'arrows':
                            // Arrow pointing right for contracted folders,
                            // arrow pointing down for expanded
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPEN,
                                                scimoz.SC_MARK_ARROWDOWN);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDER,
                                                scimoz.SC_MARK_ARROW);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERSUB,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERTAIL,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEREND,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPENMID,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERMIDTAIL,
                                                scimoz.SC_MARK_EMPTY);
                            break;
                        case 'plusminus':
                            // Plus for contracted folders, minus for expanded
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPEN,
                                                scimoz.SC_MARK_MINUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDER,
                                                scimoz.SC_MARK_PLUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERSUB,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERTAIL,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEREND,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPENMID,
                                                scimoz.SC_MARK_EMPTY);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERMIDTAIL,
                                                scimoz.SC_MARK_EMPTY);
                            break;
                        case 'curvytree':
                            // Like a flattened tree control using circular headers
                            // and curved joins
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDER,
                                                scimoz.SC_MARK_CIRCLEPLUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERSUB,
                                                scimoz.SC_MARK_VLINE);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERTAIL,
                                                scimoz.SC_MARK_LCORNERCURVE);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEREND,
                                                scimoz.SC_MARK_CIRCLEPLUSCONNECTED);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPEN,
                                                scimoz.SC_MARK_CIRCLEMINUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPENMID,
                                                scimoz.SC_MARK_CIRCLEMINUSCONNECTED);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERMIDTAIL,
                                                scimoz.SC_MARK_TCORNERCURVE);
                            break;
                        case 'squaretree':
                            // Like a flattened tree control using square headers
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPEN,
                                                scimoz.SC_MARK_BOXMINUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDER,
                                                scimoz.SC_MARK_BOXPLUS);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERSUB,
                                                scimoz.SC_MARK_VLINE);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERTAIL,
                                                scimoz.SC_MARK_LCORNER);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEREND,
                                                scimoz.SC_MARK_BOXPLUSCONNECTED);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDEROPENMID,
                                                scimoz.SC_MARK_BOXMINUSCONNECTED);
                            scimoz.markerDefine(scimoz.SC_MARKNUM_FOLDERMIDTAIL,
                                                scimoz.SC_MARK_TCORNER);
                            break;
                    }
                    scimoz.setMarginMaskN(whichMargin, scimoz.SC_MASK_FOLDERS);
                    scimoz.setProperty("fold", "1");
                    scimoz.setFoldFlags(16);
                    scimoz.setMarginWidthN(whichMargin, 15);
                ]]></body>
            </method>

            <method name="getClientCoordinates">
            <parameter name="event"/>
            <body><![CDATA[
                var x = event.clientX < 0 ? 0 : event.clientX - this.boxObject.x;
                var y = event.clientY - this.boxObject.y;
                return [x,y];
            ]]></body>
            </method>

        </implementation>

        <handlers>
            <handler event="focus" phase="capturing">
                <![CDATA[
                var scimoz = this.scimoz;
                scimoz.indicatorCurrent = this.DECORATOR_SOFT_CHAR;
                scimoz.indicatorClearRange(0, scimoz.textLength);
                scimoz.isFocused = true;
                // Ensure the command dispatcher is referencing the scintilla
                // element, not the plugin element. Otherwise commands will not
                // work correctly.
                window.document.commandDispatcher.focusedElement = this;
                ]]>
            </handler>

            <handler event="blur" phase="capturing">
                <![CDATA[
                // We need to send mouseUps if we are blurred before a mouseup naturally occurs (e.g. if the user alt-tabs).
                // Otherwise the mouseup is never picked up by scintilla and selection "keeps going on".
                if (this._inMouseDown != -1 && event.originalTarget == this) {
<!-- #if PLATFORM == "linux" -->
                  // When the focusedElement is null - this usually means that
                  // Komodo is changing focus between the embed element (SciMoz)
                  // and "xul:scintilla" - if this is the case we don't want to
                  // send the buttonUp as the user is still inside the editor.
                  // Bug 86589.
                  if (window.document.commandDispatcher.focusedElement != null) {
<!-- #endif -->
                    this.scimoz.buttonUp( this._lastMousePos[0], this._lastMousePos[1], this._inMouseDown, event.timeStamp, 0, 0, 0);
                    // The selection may have changed as a result.
                    // We could get smarter about only sending this when it truly _has_
                    // changed, but this would require remembering the position in the
                    // "mousedown" event, and speed here isnt a real issue.
                    this._inMouseDown = -1;
<!-- #if PLATFORM == "linux" -->
                  }
<!-- #endif -->
                }
                this.scimoz.isFocused = false;
                ]]>
            </handler>

            <handler event="keypress" phase="capturing">
                <![CDATA[
<!-- #if PLATFORM != "darwin" -->
                var cmdkey = event.ctrlKey || event.altKey || event.metaKey;
<!-- #else -->
                // bug 79591, allow alt keys to get through since they
                // are used for special key entry on osx.  This is dependent
                // on our patches in nsChildView.mm, changing those patches
                // may change the behaviour here as well.
                var cmdkey = event.ctrlKey || event.metaKey;
<!-- #endif -->
                var scimoz = this.scimoz;
                if (scimoz.isFocused &&
                    (event.charCode == 0 || cmdkey || this.key_handler)) {
                    // Setup a callback to check if we've moved away from the
                    // adjacent soft character.
                    var currentPos = scimoz.currentPos;
                    if (scimoz.indicatorValueAt(this.DECORATOR_SOFT_CHAR, currentPos)) {
                        if (event.keyCode == event.DOM_VK_BACK_SPACE) {
                            // Separate check to see if the current char is indicated
                            if (currentPos > 0) {
                                var rightChar = scimoz.getWCharAt(currentPos);
                                var leftChar = scimoz.getWCharAt(currentPos - 1);
                                if (!this.bracketedDecoratedChars) {
                                    this.bracketedDecoratedChars = {"(":")","{":"}", "[":"]"};
                                }
                                if (leftChar == rightChar
                                    || (leftChar in this.bracketedDecoratedChars
                                        && this.bracketedDecoratedChars[leftChar] == rightChar)) {
                                    scimoz.targetStart = currentPos;
                                    scimoz.targetEnd = currentPos + 1;
                                    scimoz.replaceTarget(0, "");
                                }
                            }
                            // And let standard handling of the backspace take place.
                        } else {
                            // harden any soft characters we move away from.  The only
                            // range of soft chars in a document are immediately to the right
                            // of the cursor on the same line.
                            setTimeout(function(this_, softPosition, softCharDecorator) {
                                var scimoz_ = this_.scimoz;
                                var newPosition = scimoz_.currentPos;
                                if (newPosition == softPosition) {
                                    return;
                                }
                                var softPositionEnd = scimoz_.indicatorEnd(softCharDecorator, softPosition)
                                var clearEndPos = ((newPosition < softPosition    // moved left
                                                    || newPosition >= softPositionEnd) // moved right of last soft char
                                                   ? softPositionEnd : newPosition);
                                if (clearEndPos > softPosition) {
                                    scimoz_.indicatorCurrent = softCharDecorator;
                                    //dump("Clear soft chars from " + softPosition + " to " + clearEndPos + "\n");
                                    scimoz_.indicatorClearRange(softPosition, clearEndPos - softPosition);
                                }
                            }, 0, this, currentPos, this.DECORATOR_SOFT_CHAR);
                        }
                    }
                }
                if (this.key_handler) {
                    // The key_handler will cancelBubble or preventDefault if it
                    // is necessary.
                    this.key_handler(event);
                    return;
                }
                if (cmdkey) {
                    // Keybindings handle these key events
                    return;
                }

                // See if scintilla component uses this event
                switch (event.keyCode) {
                    case event.DOM_VK_ENTER:
                    case event.DOM_VK_RETURN:
                        break;
                    case event.DOM_VK_TAB:
                        if (scimoz.selectionIsRectangle) {
                            if (event.shiftKey) {
                                scimoz.backTab();
                            } else {
                                scimoz.tab();
                            }
                            event.stopPropagation();
                            event.preventDefault();
                            event.cancelBubble = true;
                            return;
                        } else
                        if (scimoz.isFocused) {
                            // it's ours
                            event.preventDefault();
                            if (event.shiftKey) {
                                ko.commands.doCommand('cmd_dedent');
                            } else {
                                ko.commands.doCommand('cmd_indent');
                            }
                            return;
                        }
                        break;
                    case event.DOM_VK_ESCAPE:
                        var view = ko.views ? ko.views.manager.currentView : null;
                        if (scimoz.autoCActive()) {
                            scimoz.autoCCancel();
                            event.stopPropagation();
                            event.preventDefault();
                            event.cancelBubble = true;
                            return;
                        } else if (scimoz.callTipActive()) {
                            scimoz.callTipCancel();
                            event.stopPropagation();
                            event.preventDefault();
                            event.cancelBubble = true;
                            return;
                        } else if (view && ko.tabstops) {
                            ko.tabstops.clearTabstopInfo(view);
                        }
                        if (view) {
                            view.clearMatchingTag();
                        }
                        break;
                    case event.DOM_VK_DELETE:
                        if (ko.tabstops) {
                            ko.tabstops.handleDelete(scimoz);
                        }
                        if (scimoz.selectionIsRectangle) {
                            scimoz.clear();
                            event.stopPropagation();
                            event.preventDefault();
                            event.cancelBubble = true;
                            return;
                        }
                        break;                    
                    case event.DOM_VK_BACK_SPACE:
                        if (ko.tabstops) {
                            ko.tabstops.handleBackspace(scimoz);
                        }
                        if (scimoz.selectionIsRectangle) {
                            scimoz.deleteBack();
                            event.stopPropagation();
                            event.preventDefault();
                            event.cancelBubble = true;
                            return;
                        }
                        break;                    
                }
                if (event.charCode == 0) {
                    return;
                }

                if (scimoz.isFocused) {
                    //dump("event.charCode: " + event.charCode + ", pos " + scimoz.currentPos + "\n");
                    var currentPos = scimoz.currentPos;
                    if (scimoz.indicatorValueAt(this.DECORATOR_SOFT_CHAR, currentPos)
                        && event.charCode == scimoz.getCharAt(currentPos)) {
                        scimoz.indicatorCurrent = this.DECORATOR_SOFT_CHAR;
                        scimoz.indicatorClearRange(currentPos, 1);
                        if (scimoz.autoCActive()) {
                            // Do this to remove an interaction between
                            // the auto-complete mechanism and the soft-character mechanism
                            // when the trigger character is also a soft character.
                            // Only current case (2007-07) is for Ruby require statements.
                            scimoz.autoCCancel();
                        }
                        scimoz.gotoPos(currentPos + 1);
                    } else {
                        scimoz.addChar(event.charCode);
                    }
                    event.stopPropagation();
                    event.preventDefault();
                    event.cancelBubble = true;
                    if (typeof(ko.macros) != 'undefined' && ko.macros.recorder.mode == 'recording') {
                        ko.macros.recorder.recordKeyPress(String.fromCharCode(event.charCode));
                    }
                }
                ]]>
            </handler>

            <handler event="text" phase="capturing">
                <![CDATA[
                this.scimoz.handleTextEvent(event);
                ]]>
            </handler>

<!-- #if PLATFORM != "darwin" -->
            <handler event="keyup" phase="capturing"><![CDATA[
                if (event.keyCode == event.DOM_VK_ALT && this.needToStopAltPropagation) {
                    event.stopPropagation();
                    event.preventDefault();
                    this.needToStopAltPropagation = false;
                }
            ]]></handler>
<!-- #endif -->

            <handler event="keydown" phase="capturing">
                <![CDATA[
                if (this.key_handler) {
                    // The key_handler will cancelBubble or preventDefault if it
                    // is necessary.
                    this.key_handler(event);
                    return;
                }
                ]]>
            </handler>

            <handler event="mouseup" phase="capturing">
                <![CDATA[
                //dump("scintilla: mouseup\n");
                var scimoz = this.scimoz;
                scimoz.indicatorCurrent = this.DECORATOR_SOFT_CHAR;
                scimoz.indicatorClearRange(0, scimoz.textLength);
                if (event.button != 2) { // right-click is handled by us
                    
<!-- #if PLATFORM != "darwin" and PLATFORM != "win" -->
                    var x,y;
                    [x,y] = this.getClientCoordinates(event);

                    // only disable scintilla mouseup if this is a single left button
                    // click.  Otherwise selections get disabled on linux
                    if (this.inDragDrop && event.detail == 1 && event.button==0) {
                        //dump('scintilla reset mouseup positions\n');
                        var pos = scimoz.positionFromPoint(x, y);
                        scimoz.selectionStart = scimoz.selectionEnd = pos;
                        scimoz.currentPos = pos;
                        scimoz.dragPosition = -1;

                    // SciMoz.buttonUp does nothing on Linux, so commenting out
                    // this pointless xpcom call - toddw.
                    //} else {
                    //    scimoz.buttonUp( x, y,
                    //                        event.button,
                    //                        event.timeStamp,
                    //                        event.shiftKey, event.ctrlKey, event.metaKey);
                    }
<!-- #endif -->

                    this._startDragDrop = null;

                    // The selection may have changed as a result.
                    if (scimoz.selText != this._mouseDownSelection) {
                        window.updateCommands("select");
                    }
                    this._mouseDownSelection = "";
                    this._inMouseDown = -1;
                } else if (this._mozcontext && !this._contextShowing) {
                    this._mozcontext.openPopup(
                        null, // anchor on the Komodo window
                        null, // ignore if anchorElement is null
                        // Offset by 2 pixels to allow clicking in same place
                        // to dismiss the context menu as per:
                        // http://developer.mozilla.org/en/docs/XUL:PopupGuide:Positioning
                        // > Context menus will appear offset down and to the
                        // > right a couple of pixels so that the menu can be
                        // > dismissed again just by clicking in the same place.
                        event.clientX + 2,
                        event.clientY + 2,
                        true);
                    this._contextShowing = true;
                }
                ]]>
            </handler>

<!-- #if PLATFORM == "darwin" -->
            <handler event="mouseover" phase="capturing">
                <![CDATA[
                    if (this._inMouseDown == -1) return;
                    if (this._mouseUpEvent) {
                        window.removeEventListener("mouseup", this._mouseUpEvent, true);
                        this._mouseUpEvent = null;
                    }
                ]]>
            </handler>

            <handler event="mouseout" phase="capturing">
                <![CDATA[
                    if (this._inMouseDown == -1) return;
                    // for osx, handle a mouseup event that occurs outside of the
                    // plugin.  bug 80273
                    var self = this;
                    this._mouseUpEvent = function(event) {
                        var x,y;
                        [x,y] = self.getClientCoordinates(event);
                        self.scimoz.buttonUp( x, y,
                                            event.button,
                                            event.timeStamp,
                                            event.shiftKey, event.ctrlKey, event.metaKey);
                        window.removeEventListener("mouseup", self._mouseUpEvent, true);
                        self._mouseUpEvent = null;
                        self._inMouseDown = -1;
                    }
                    window.addEventListener("mouseup", this._mouseUpEvent, true);
                ]]>
            </handler>
<!-- #endif -->

            <handler event="mousedown" phase="capturing">
                <![CDATA[
                var scimoz = this.scimoz;
                if (!scimoz.isFocused) {
                    // Focus on this Scintilla now.
                    this.focus();
                }
                var x,y;
                [x,y] = this.getClientCoordinates(event);
                this._mouseDownSelection = scimoz.selText;
                this._lastMousePos = [x,y];
                if (this._contextShowing && this._mozcontext) {
                    // XXX http://bugs.activestate.com/show_bug.cgi?id=20537
                    this._mozcontext.hidePopup();
                    this._contextShowing = false;
                }

                if (this.mouse_handler) {
                    this.mouse_handler(event);
                }
                this._startDragDrop = null;
                // No need to check X or Y are in range, as we will only get
                // this event when we do!
                var pos = scimoz.positionFromPoint(x, y);
                if (event.button != 2) { // right-click is handled by us
                    this._inMouseDown = event.button;
                    //dump('pos: '+pos+' s: '+scimoz.selectionStart+' e: '+scimoz.selectionEnd+' style: '+scimoz.getStyleAt(pos)+'\n');
                    // If the mousedown is within a selection, start drag/drop.
                    // shift key is used to make a selection with the mouse, and
                    // is not associated with drag/drop as is ctrl.  If the
                    // shift key is pressed on click, always pass to scintilla.
                    if ((event.detail == 1) && !event.shiftKey &&
                        (scimoz.selectionStart != scimoz.selectionEnd) &&
                        // Note: positionFromPointClose will return -1 if it's
                        //       not close to any characters, i.e. when clicking
                        //       on the margin or past the end of the line.
                        (scimoz.positionFromPointClose(x, y) >= 0) &&
                        (pos >= scimoz.selectionStart) &&
                        (pos <= scimoz.selectionEnd+1)) {
                        this._startDragDrop = [x,y];
                    }
                } else if (scimoz.selectionStart == scimoz.selectionEnd ||
                        pos < scimoz.selectionStart ||
                        pos > scimoz.selectionEnd+1) {
                    // if we right click, put the cursor there unless we're clicking
                    // on a selection
                    scimoz.selectionStart = scimoz.selectionEnd = pos;
                }
<!-- #if PLATFORM != "darwin" -->
                if (event.altKey) {
                    this.needToStopAltPropagation = true;
                }
<!-- #endif -->
                ]]>
            </handler>
            <handler event="mousemove">
                <![CDATA[
            try {
                var x,y;
                [x,y] = this.getClientCoordinates(event);
                // Use by blur event for handling text selection with the mouse.
                this._lastMousePos = [x,y];

                // Note we seem to get mousemove messages every second or so.  I
                // think it is related to the cursor, but not sure.  It seems to originate
                // from Windows itself, but I don't know what triggers it.  mh.
<!-- #if PLATFORM == "darwin" -->
                // darwin and windows handle this (somewhat differently) in
                // scimoz now
                this.scimoz.buttonMove( x, y );
<!-- #endif -->
            } catch (e) {
                this.log.exception(e);
            }
                ]]>
            </handler>

            <handler event="DOMMouseScroll" phase="capturing">
            <![CDATA[
            var rows = event.detail;
            if (event.ctrlKey && event.shiftKey) {
                if (rows > 0)
                    this.scimoz.zoomIn();
                else if (rows < 0)
                    this.scimoz.zoomOut();
            } else {
                if (rows == NSUIEvent.SCROLL_PAGE_UP ||
                    (rows < 0 && event.ctrlKey))
                    rows = -this.scimoz.linesOnScreen;
                else if (rows == NSUIEvent.SCROLL_PAGE_DOWN ||
                    (rows > 0 && event.ctrlKey))
                    rows = this.scimoz.linesOnScreen;
		    
                if (event.shiftKey)
                    this.scimoz.lineScroll(rows,0);
                else
                    this.scimoz.lineScroll(0,rows);
            }
            ]]>
            </handler>


            <!--
            ####################################
            Scintilla drag/drop handling
            ####################################
            -->

            <handler event="dragstart">
                <![CDATA[
                // Starting a drag operation in Scintilla.
                //dump("dragstart\n");
                if (this.inDragDrop) {
                    var selection = this.scimoz.selText;
                    if (selection) {
                        event.dataTransfer.setData("text/plain", selection);
                        event.dataTransfer.effectAllowed = 'copyMove';
<!-- #if PLATFORM != "darwin" -->
                        this._dragScrollHits = 0;
<!-- #endif -->
                    }
                }
                ]]>
            </handler>

            <!--
            <handler event="dragenter" capturing="true">
                <![CDATA[
                // Drag operation is entering the Scintilla element.
                dump("dragenter\n");
                ]]>
            </handler>
            -->

            <handler event="dragover">
                <![CDATA[
                //dump("dragover\n");
                // Automatically scroll Scintilla up/down when the drag
                // cursor moves to the top/bottom of the visible document.
                var scimoz = this.scimoz;
                var x = event.clientX < 0 ? 0 : event.clientX - this.boxObject.x;
                var y = event.clientY - this.boxObject.y; // Must allow this to be -ve so we scroll up
                var pos = scimoz.positionFromPoint(x, y);
<!-- #if PLATFORM != "darwin" -->
                var docLine = scimoz.lineFromPosition(pos);
                var visibleLine = scimoz.visibleFromDocLine(docLine);
                if (visibleLine <= scimoz.firstVisibleLine) {
                    if (this._dragScrollHits++ > 10) {
                        scimoz.lineScroll(0,-5);
                    } else {
                        scimoz.lineScroll(0,-1);
                    }
                    pos = scimoz.positionFromPoint(x, y);
                } else if (visibleLine >= scimoz.firstVisibleLine + scimoz.linesOnScreen - 1) {
                    if (this._dragScrollHits++ > 10) {
                        scimoz.lineScroll(0,5);
                    } else {
                        scimoz.lineScroll(0,1);
                    }
                    pos = scimoz.positionFromPoint(x, y);
                } else {
                    this._dragScrollHits=0;
                }
<!-- #endif -->
                scimoz.dragPosition = pos;

                // If you want to allow a drop, you must prevent the default
                // handling by cancelling the event, or by returning false.
                return false;
                ]]>
            </handler>

            <handler event="dragleave">
                <![CDATA[
                // The drag/drop operation is leaving/ending for Scintilla.
                //dump("scintilla: dragleave\n");
                this.scimoz.dragPosition = -1;
                ]]>
            </handler>

            <!--
            <handler event="drag">
                <![CDATA[
                dump("drag\n");
                ]]>
            </handler>
            -->

            <handler event="drop">
                <![CDATA[
                //dump("scintilla: drop\n");
<!-- #if PLATFORM != "darwin" -->
                this._dragScrollHits = 0;
<!-- #endif -->
                var dataTransfer = event.dataTransfer;
                if (!dataTransfer.mozItemCount) {
                    // Nothing to do.
                    return false;
                }

                var x = event.clientX < 0 ? 0 : event.clientX - this.boxObject.x;
                var y = event.clientY - this.boxObject.y; // Must allow this to be -ve so we scroll up
                var scimoz = this.scimoz;
                var pos = scimoz.positionFromPoint(x, y);
                var onselection = (pos > scimoz.selectionStart &&
                                    pos < scimoz.selectionEnd);

                scimoz.dragPosition = -1;
                var text;
                if (ko && typeof(ko.dragdrop) != 'undefined') {
                    // Allows for text/html drop types as well.
                    var dropFlavours = ko.dragdrop.genericSupportedFlavours.concat("text/html");
                    dropFlavours.unshift('application/x-komodo-snippet');
                    var koDragDropList = ko.dragdrop.unpackDropData(event.dataTransfer, dropFlavours);
                    if (!koDragDropList) {
                        // Cannot handle any of the dropped data.
                        return false;
                    }
                    var unhandledDropData = ko.dragdrop.openDroppedUrls(koDragDropList);
                    if (!unhandledDropData) {
                        // The generic Komodo drop handler did all the work.
                        event.preventDefault();
                        return true;
                    }

                    if (unhandledDropData.length > 1) {
                        this.log.warn('onDrop:: received multiple drop data, ' +
                                      'only handling the first one.');
                    }
                    var koDropData;
                    for (var i=0; i < unhandledDropData.length; i++) {
                        koDropData = unhandledDropData[i];
                        if (koDropData.isSnippet && koDropData.snippet) {
                            if (!onselection) {
                                scimoz.gotoPos(pos);
                            }
                            ko.projects.snippetInsert(koDropData.snippet);
                            // We handled the snippet.
                            event.preventDefault();
                            return true;
                        }
                        if (koDropData.isHTML && koDropData.alternatives["text/plain"]) {
                            // TODO: Should have some UI to choose between the
                            // HTML version and the text version. For now we
                            // just take the text.
                            this.log.info("Both text and HTML data available - choosing text");
                            text = koDropData.alternatives["text/plain"].value;
                        } else {
                            text = koDropData.dragData;
                        }
                        break;
                    }
                } else {
                    // Get the first supported drop data.
                    text = dataTransfer.mozGetDataAt(dataTransfer.mozTypesAt(0)[0], 0);
                }

                if (!text) {
                    // Nothing to handle.
                    return false;
                }

                // rules:
                // 1. if it's a snippet, use the regular snippet handler to insert it
                // 2. if from outside scimoz
                //   a. dropped on selection, replace selection
                //   b. insert text
                // 3. if from inside scimoz (startdragdrop == true)
                //   a. if droped on selection, cancel
                //   b. if action copy, insert text
                //   c. if action move, remove old, insert text

                // first, convert line endings the correct style for this
                // document, since the text could have come from anywhere
                var eol = [];
                eol[Components.interfaces.ISciMoz.SC_EOL_CR] = '\r';
                eol[Components.interfaces.ISciMoz.SC_EOL_CRLF] = '\r\n';
                eol[Components.interfaces.ISciMoz.SC_EOL_LF] = '\n';
                text = text.replace(/(\r\n|\n|\r)/g, eol[scimoz.eOLMode]);
                var endUndoAction = true;
                scimoz.beginUndoAction();
                try {
<!-- #if PLATFORM == "darwin" -->
                    if (scimoz.inDragSession)
<!-- #else -->
                    if (this.inDragDrop) 
<!-- #endif -->
                    {
                        // data from inside scimoz
                        if (onselection) {
                            event.preventDefault();
                            return true;
                        }
                        var start = scimoz.selectionStart;
                        var length = scimoz.selectionEnd - start;
                        if (event.dataTransfer.dropEffect == "move") {
                            scimoz.replaceSel(''); // remove the dragged text
                            if (start < pos) pos -= length; // adjust where we insert our data
                        }
                    } else {
                        // data from outside scimoz
                        if (onselection) {
                            pos = scimoz.selectionStart;
                            scimoz.replaceSel('');
                        } else {
                            scimoz.gotoPos(pos);
                        }
                    }
                    this.focus();
                    // Bug 81413: This must be done after `this.focus()`.
                    // Don't know what about `this.focus()` is resetting the
                    // current position.
                    scimoz.insertText(pos, text);
                    scimoz.selectionStart = pos;
                    scimoz.selectionEnd = pos+stringutils_bytelength(text);
                } finally {
                    if (endUndoAction) {
                        scimoz.endUndoAction();
                    }
                }
                scimoz.endDrop();

                // We're handling all (or at least part) of this drop data.
                event.preventDefault();
                return true;
                ]]>
            </handler>

            <handler event="dragend" capturing="true">
                <![CDATA[
                // The initial drag operation that started in Scintilla is now
                // ended.
                //dump("scintilla: dragend\n");
                this._startDragDrop = null;
<!-- #if PLATFORM == "win" -->
                    // Ensure the mouse capture is released - bug 87342.
                    this.scimoz.endDrop();
<!-- #endif -->
                ]]>
            </handler>

        </handlers>
    </binding>

</bindings>
