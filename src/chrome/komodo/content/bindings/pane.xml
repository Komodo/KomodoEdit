<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Komodo.
   -
   - The Initial Developer of the Original Code is
   - ActiveState Software Inc.
   - Portions created by the Initial Developer are Copyright (C) 2011
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
<!DOCTYPE bindings PUBLIC "-//MOZILLA//DTD XBL V1.0//EN" "http://www.mozilla.org/xbl" [
  <!ENTITY % komodoDTD SYSTEM "chrome://komodo/locale/komodo.dtd">
  %komodoDTD;
]>

<bindings
    xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<!--
  - Panes for sidebars and the like
  - See kd 0272 for specifications
  -->

  <binding id="pane" extends="chrome://global/content/bindings/tabbox.xml#tabbox">
    <content>
      <xul:hbox class="pane-tabs-container">
        <!-- this is for the "sidebar" and "horzontal" modes -->
        <xul:tabs anonid="tabs"
                  closecollapsed="false"
                  orient="this is here to prevent the tabs binding setting it to horizontal"
                  xbl:inherits="rotation,label=tabLabel"
                  oncontextmenu="return document.getBindingParent(this)._onTabContext(event);"
                  onclose="var elem = this;
                           while (!/pane/.test(elem.localName))
                             elem = document.getBindingParent(elem);
                           elem.collapsed = true;"/>
      </xul:hbox>
      <xul:vbox flex="1">
        <!-- this is here for the "vertical" case -->
        <xul:hbox class="tabs-vertical-label">
          <xul:label xbl:inherits="value=tabLabel"/>
          <xul:spacer/>
          <xul:toolbarbutton anonid="panel-close-button"
                  class="tabs-closebutton"
                  buttonstyle="pictures"
                  oncommand="document.getBindingParent(this).collapsed = true;"/>
        </xul:hbox>
        <xul:tabpanels anonid="tabpanels" flex="1">
          <children/>
        </xul:tabpanels>
      </xul:vbox>

      <xul:menupopup anonid="tabs_popup">
        <xul:menu label="&pane.moveTo.label;">
          <xul:menupopup anonid="tabs_popup_moveto"/>
        </xul:menu>
      </xul:menupopup>
    </content>
    <implementation>
      <method name="addWidget">
        <!--
          - Add the given widget to the pane
          -->
        <parameter name="widget"/>
        <body>
        <![CDATA[
          if (!widget.tab) {
            this._log.debug("Widget " + widget.id + " has no tab, creating one (" + this.id + ")");
            var tab = this.ownerDocument.createElementNS(this.namespaceURI, "tab");
            tab.setAttribute("observes", widget.id);
            tab.setAttribute("linkedpanel", widget.id);
            tab.addEventListener("contextmenu", (function(event) {
              this._updateMoveToPopup(event);
              var popup = document.getAnonymousElementByAttribute(this, "anonid", "tabs_popup");
              popup.openPopup(tab, "after_pointer", 0, 0, true, false, event);
            }).bind(this), false);
            // copy any attributes over that start with "tab_" without the prefix
            // so we can have things like oncommand
            for (var [index, attr] in Iterator(widget.attributes)) {
              if (/^tab_/.test(attr.name)) {
                // copy the attribute over
                tab.setAttribute(attr.name.replace(/^tab_/, ""), attr.value);
                // add a <observes> to catch the attribute changing dynamically
                var observes = this.ownerDocument.createElementNS(this.namespaceURI, "observes");
                observes.setAttribute("element", widget.id);
                observes.setAttribute("attribute", attr.name);
                observes.addEventListener("broadcast", (function(event){
                  var observes = event.target;
                  var attr = observes.getAttribute("attribute");
                  observes.parentNode.setAttribute(attr.replace(/^tab_/, ""),
                                                   this.getAttribute(attr));
                }).bind(widget), false);
                tab.appendChild(observes);
              }
            }
            widget.tab = tab;
          }
          this._log.debug("Adding tab " + widget.tab.getAttribute("label") + " for " + widget.id);
          this.tabs.appendChild(widget.tab);
          // we never want to have flex by the attr; remove the flex generated
          // by the tab binding. (we can do it from css if we really want to.)
          widget.tab.removeAttribute("flex");
          this.tabpanels.appendChild(widget);

          // update the menu listing the widgets to show
          var refElem = document.getElementById("menu_view_tabs_stub_" + this.id);
          if (refElem) {
            var menuitem = document.createElement("menuitem");
            menuitem.setAttribute("label", widget.getAttribute("label"));
            menuitem.setAttribute("type", "checkbox");
            menuitem.setAttribute("widget", widget.id);
            refElem.parentNode.insertBefore(menuitem, refElem);
            menuitem.addEventListener("command",
                                      ko.uilayout.ensureTabShown.bind(ko.uilayout, widget, true),
                                      false);
            widget._menuitem = menuitem;
          }
        ]]>
        </body>
      </method>

      <method name="removeWidget">
        <!--
          - Remove a given widget.
          - This should not be used if you just want to hide the widget
          - temporarily.
          -->
        <parameter name="widget"/>
        <body>
        <![CDATA[
          if (widget.parentNode) {
            widget.parentNode.removeChild(widget);
          }
          if (widget.tab) {
            if (widget.tab.parentNode) {
              // find another tab to select
              var tab = widget.tab.nextElementSibling;
              for (; tab; tab = tab.nextElementSibling) {
                if (!tab.hasAttribute("collapsed")) {
                  break;
                }
              }
              if (!tab) {
                tab = widget.tab.previousElementSibling;
                for (; tab; tab = tab.previousElementSibling) {
                  if (!tab.hasAttribute("collapsed")) {
                    break;
                  }
                }
              }
              if (tab) {
                this.selectedTab = tab;
              } else {
                // we're removing the only visible widget. Hide.
                this.collapsed = true;
              }
              widget.tab.parentNode.removeChild(widget.tab);
            }
            widget.tab = null;
          }
          // update the menu listing the widgets
          var refElem = document.getElementById("menu_view_tabs_stub_" + this.id);
          var menu = refElem.parentNode;
          var menuitem = widget._menuitem;
          if (!menuitem) {
            menuitem = menu.querySelector("menuitem[widget='" + widget.id + "']");
          }
          if (menuitem) {
            menuitem.parentNode.removeChild(menuitem);
          }
        ]]>
        </body>
      </method>

      <method name="_updateMoveToPopup">
        <parameter name="event"/>
        <body>
        <![CDATA[
          var tab = event.target;
          var popup = document.getAnonymousElementByAttribute(this, "anonid", "tabs_popup_moveto");
          while (popup.firstChild) {
            popup.removeChild(popup.firstChild);
          }
          var widget = document.getElementById(tab.getAttribute("linkedpanel"))
          popup.setAttribute("_widgetToMove", widget.id);
          for each (var paneid in Object.keys(ko.widgets._panes)) {
            var pane = ko.widgets._panes[paneid];
            var menuitem = document.createElementNS(this.namespaceURI, "menuitem");
            menuitem.setAttribute("label", pane.getAttribute("label") || pane.id);
            menuitem.setAttribute("type", "checkbox");
            menuitem.setAttribute("_paneId", pane.id);
            if (widget.tabbox == pane) {
              // it's alreayd here
              menuitem.setAttribute("disabled", true);
              menuitem.setAttribute("checked", true);
            }
            menuitem.addEventListener("command", (function(event) {
              this.moveWidgetToPane(popup.getAttribute("_widgetToMove"),
                                    event.target.getAttribute("_paneId"));
            }).bind(this), false);
            popup.appendChild(menuitem);
          }
        ]]>
        </body>
      </method>

      <method name="_onTabContext">
        <!--
          - This handles context menu events on the <tabs> (and children)
          -->
        <parameter name="event"/>
        <body>
        <![CDATA[
          var elem = event.originalTarget;
          var tab = null;
          for (; elem && elem != event.target; elem = elem.parentNode) {
            if (elem.getAttribute("anonid") == "label-box") {
              // this is the label for <tabs type="sidebar">
              tab = document.getBindingParent(elem).selectedItem;
              break;
            }
            if (elem.localName == "menuitem" && elem.tab) {
              // this is a menu item
              tab = elem.tab;
              break;
            }
          }
          if (tab) {
            // found an interesting element
            this._updateMoveToPopup({target: tab});
            var popup = document.getAnonymousElementByAttribute(this, "anonid", "tabs_popup");
            popup.openPopup(elem, "after_pointer", 0, 0, true, false, event);
            return;
          }
        ]]>
        </body>
      </method>
      
      <method name="moveWidgetToPane">
        <!--
          - Move a widget to a given pane
          - @param widget {str or ko-widget} The widget to move (or its id)
          - @param pane {str or ko-pane} The pane to move to (or its id)
          - @param focus {boolean} Whether to focus the widget after moving
          -         (defaults to true)
          -->
        <parameter name="widget"/>
        <parameter name="pane"/>
        <parameter name="focus"/>
        <body>
        <![CDATA[
          // sanity check the input, because it always pays to have good error
          // messages... (also, this is an API people might want to use)
          if (!widget._is_ko_widget) {
            var widgetId = widget;
            widget = document.getElementById(widgetId);
            if (!widget) {
              var error = new Error("widget " + widgetId + " not found");
              Components.utils.reportError(error);
              throw(error);
            }
            widgetId = (widgetId.id) ? widgetId.id : widgetId;
            if (!widget._is_ko_widget) {
              var error = new Error(widgetId + " is not a ko-widget");
              Components.utils.reportError(error);
              throw(error);
            }
          }
          if (!pane.addWidget) {
            var paneId = pane;
            pane = document.getElementById(paneId);
            if (!pane) {
              var error = new Error("pane" + paneId + " not found");
              Components.utils.reportError(error);
              throw(error);
            }
            paneId = (paneId.id) ? paneId.id : paneId;
            if (!("addWidget" in pane)) {
              var error = new Error(paneId + " is not a ko-pane");
              Components.utils.reportError(error);
              throw(error);
            }
          }
          if (typeof(focus) == "undefined") {
            focus = true;
          }
          var oldPane = widget.tabbox;
          if (oldPane == pane) {
            this._log.debug("Skipping moving widget " + widget.id +
                            ", already in " + pane.id);
            return;
          }

          var nextTab = widget.tab.nextElementSibling ||
                        widget.tab.previousElementSibling;
          if (oldPane.selectedTab != widget.tab) {
            // we still might need to switch selected widget, if we're removing
            // a widget with a lower index (so <tabpanels>.selectedIndex will
            // be too large).
            nextTab = oldPane.selectedTab;
          }

          this._log.debug("moving widget " + widget.id + " to " + pane.id);

          // dispatch an event into the widget so they can stop this if they
          // want to veto it, or otherwise do some preparation
          var event = widget.contentDocument.createEvent("DataContainerEvent");
          event.initEvent("ko-widget-move", true /*bubble*/, true /*cancel*/);
          event.setData("from-pane", oldPane);
          event.setData("to-pane", pane);
          widget.contentDocument.dispatchEvent(event);
          if (event.getPreventDefault()) {
            // the widget asked us to stop
            return;
          }

          // create a target ko-widget to stuff things into
          // "id", "src", and "disablehistory" are special
          var widgetId = widget.id;
          widget.id = null;
          var newWidget = pane.ownerDocument.createElementNS(this.namespaceURI, "browser");
          newWidget.setAttribute("disablehistory", true);
          newWidget.setAttribute("id", widgetId);
          var widgetSrc = widget.getAttribute("src");
          newWidget.setAttribute("src", widgetSrc);
          var attr;
          for ([,attr] in Iterator(widget.attributes)) {
            if (attr && attr.name != "src" && attr.name != "id") {
              newWidget.setAttributeNS(attr.namespaceURI, attr.name, attr.value);
            }
          }

          // Do the swap
          pane.addWidget(newWidget);
          newWidget.swapDocShells(widget);

          // move the observers over
          var oldBroadcasters = document.getAnonymousElementByAttribute(widget, "anonid", "pane_broadcasterset");
          var newBroadcasters = document.getAnonymousElementByAttribute(newWidget, "anonid", "pane_broadcasterset");
          while (oldBroadcasters.firstChild) {
            newBroadcasters.appendChild(oldBroadcasters.firstChild);
          }

          // remove the old widget
          var attrs = [attr for ([,attr] in Iterator(widget.attributes)) if (attr)];
          for each (attr in attrs) {
            if (attr.name != "disablehistory")
              widget.removeAttributeNode(attr);
          }
          pane.removeWidget(widget);
          if (nextTab) {
            // need to select some other tab now that the old one is gone
            this._log.debug("switching to alternate widget " + nextTab.getAttribute("label"));
            ko.uilayout.ensureTabShown(nextTab, false);
          }

          // set the focus if requested
          if (focus) {
            ko.uilayout.ensureTabShown(newWidget.id, true);
          }

          // dispatch an event into the widget to notify that we've done the move
          // (this is dead last so it has a chance to do random things like,
          // say, deciding to focus a different widget...)
          var event = newWidget.contentDocument.createEvent("DataContainerEvent");
          event.initEvent("ko-widget-move-completed", true /*bubble*/, false /*cancel*/);
          event.setData("from-pane", oldPane);
          event.setData("to-pane", pane);
          newWidget.contentDocument.dispatchEvent(event);
        ]]>
        </body>
      </method>

      <property name="splitter">
        <getter>
        <![CDATA[
          for each (var elem in [this.previousElementSibling, this.nextElementSibling]) {
            if (elem && elem.namespaceURI == this.namespaceURI && elem.localName == "splitter") {
              return elem;
            }
          }
          return null;
        ]]>
        </getter>
      </property>
      <property name="tabs">
        <getter>
          return this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "tabs");
        </getter>
      </property>
      <property name="tabpanels">
        <getter>
          return this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "tabpanels");
        </getter>
      </property>
      <property name="collapsed">
        <getter>
        <![CDATA[
          // somebody silly somewhere is setting collapsed to empty string (which
          // isn't considered to be collapsed), so we have to check for that too
          return !!this.getAttribute("collapsed");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          /* note that the splitter is expected to observe the collapsed attr
           * on this element, and the toolbar button is expected to observe the
           * checked attr
           */
          if (val) {
            this.setAttribute("collapsed", true);
            this.removeAttribute("checked"); // for reflecting to toolbarbutton
          } else {
            this.removeAttribute("collapsed");
            this.setAttribute("checked", true);
          }
        ]]>
        </setter>
      </property>

      <field name="_log">ko.logging.getLogger("ko-pane")</field>

      <constructor>
      <![CDATA[
      try{
        if (!this.hasAttribute("type")) {
          // no type; this leads to broken UI, so default to something
          this.setAttribute("type", "sidebar");
        }
        if (this.hasAttribute("pref")) {
          // the type of this pane is persisted in prefs
          var prefs = Components.classes["@activestate.com/koPrefService;1"]
                                .getService(Components.interfaces.koIPrefService)
                                .effectivePrefs;
          var prefid = this.getAttribute("pref");
          if (prefs.hasStringPref(prefid)) {
            this.setAttribute("type", prefs.getStringPref(prefid));
          }
        }
        
        // register this pane. TODO: use some sort of API for this.
        if (!ko) window.ko = {};
        if (!ko.widgets) ko.widgets = {};
        if (!ko.widgets._panes) ko.widgets._panes = {};
        ko.widgets._panes[this.id] = this;
        
        // re-inserting the tabpanel in the same place causes it to show up
        // in DOM inspector's tree (still as a anonymous node)...
        // (this is not strictly necessary, since things still work without it)
        this.tabpanels.parentNode.insertBefore(this.tabpanels, this.tabpanels.nextSibling);
        // re-insert the widgets so we can properly construct tabs for them
        var widgets = Array.slice(this.childNodes);
        for each (var widget in widgets) {
          this.addWidget(widget);
        }
      } catch (e) { Components.utils.reportError(e); }
      ]]>
      </constructor>
    </implementation>
    <handlers>
      <handler event="select" phase="bubbling">
      <![CDATA[
        if (event.originalTarget == this.tabs) {
          var tab = this.tabs.selectedItem;
          this.setAttribute("tabLabel", tab.label);
          var panel = this.ownerDocument.getElementById(tab.linkedPanel);
          this.tabpanels.selectedPanel = panel;
        }
      ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="pane-browser" extends="chrome://global/content/bindings/browser.xml#browser">
    <content disablehistory="true">
      <broadcasterset anonid="pane_broadcasterset"/>
      <children/>
    </content>

    <implementation>
      <method name="hookupObservers">
        <!--
          - hook up the observes= elements in the child document so they work
          - @param containerElement An element in the child document that can be
          -         used to hold generated elements
          - @param parentNode [optional] the node from which to look for observes=
          -         attributes; defaults to the content document
          -->
        <parameter name="containerElement"/>
        <parameter name="parentNode"/>
        <body>
        <![CDATA[
          if (typeof(containerElement) == "string") {
            containerElement = this.contentDocument.getElementById(containerElement);
          } else if (!containerElement) {
            containerElement = this.contentDocument.documentElement;
          }
          var parentSet = this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", "pane_broadcasterset");

          var onBroadcast = (function onBroadcast(aCmdId) {
            if (typeof(aCmdId) != "string") {
              // This is not a string; therefore, it's an onbroadcast event.
              // Figure out the target element and read the id off that.
              aCmdId = aCmdId.target.getAttribute("element");
            }
            var srcCmd = this.ownerDocument.getElementById(aCmdId);
            var destCmd = this.contentDocument.getElementById(aCmdId);
            for each (let attr in Array.slice(destCmd.attributes)) {
                if (!srcCmd.hasAttribute(attr.name))
                    destCmd.removeAttribute(attr.name);
            }
            for each (let attr in Array.slice(srcCmd.attributes)) {
                destCmd.setAttributeNS(attr.namespaceURI, attr.name, attr.value);
            }
          }).bind(this);

          // Find all elements with observes= attributes and create proxying
          // <observes> elements in the parent document, and <command> elements
          // in the child document.
          if (!parentNode) parentNode = this.contentDocument;
          var elems = Array.slice(parentNode.querySelectorAll("[observes]"));
          for each (let elem in elems) {
            let cmdId = elem.getAttribute("observes");
            let srcCmd = this.ownerDocument.getElementById(cmdId);
            if (!srcCmd) continue; // not observing into the parent
            let destCmd = this.contentDocument.getElementById(cmdId);
            if (!destCmd) {
              // create a <command> in the child document and force refresh
              destCmd = this.contentDocument.createElement("command");
              destCmd.setAttribute("id", cmdId);
              containerElement.appendChild(destCmd);
              onBroadcast(cmdId);

              // create a <observes> in the parent and listen for changes
              let observer = this.ownerDocument.createElement("observes");
              observer.setAttribute("element", cmdId);
              observer.setAttribute("attribute", "*");
              parentSet.appendChild(observer);
              observer.addEventListener("broadcast", onBroadcast, false);
            }
            // re-insert the element to make sure observes= gets hooked up :(
            elem.parentNode.insertBefore(elem, elem.nextSibling);
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      <handler event="DOMWindowCreated" phase="target"><![CDATA[
        // inject the bits the content window will need; this is the exposed API.
        this.contentWindow.parent = window;
        ["ko", "xtk", "gEditorTooltipHandler"].forEach(function(prop) {
          this.contentWindow.__defineGetter__(prop, function()window[prop]);
        }, this);
      ]]></handler>
    </handlers>
  </binding>

  <binding id="widget" extends="#pane-browser">
    <!--
      - A widget to be displayed in a <ko-pane>.
      - It's a cross between a <tabpanel> and a <browser>.
      - Instantiate as <browser type="ko-widget">
      -->
    <implementation>
      <property name="tabbox">
        <getter>
        <![CDATA[
          /**
           * This is more complicated than normal because we want to look for
           * any element that uses the tabbox binding, instead of matching on
           * the tag name.
           */
          var utils = Components.classes["@mozilla.org/inspector/dom-utils;1"]
                                .getService(Components.interfaces.inIDOMUtils);
          const TABBOX_URL = "chrome://global/content/bindings/tabbox.xml#tabbox";
          var result = null;
          for (var parent = this.parentNode; !result && parent; parent = parent.parentNode) {
              if (!(parent instanceof Element)) continue;
              var urls = utils.getBindingURLs(parent).enumerate();
              while (urls.hasMoreElements()) {
                  var uri = urls.getNext().QueryInterface(Components.interfaces.nsIURI);
                  if (uri.spec == TABBOX_URL) {
                      result = parent;
                      break;
                  }
              }
          }
          return result;
        ]]>
        </getter>
      </property>
      
      <!-- This is just here because instanceof isn't going to work with XBL -->
      <field name="_is_ko_widget">true</field>
      <constructor>
      <![CDATA[
        if (!this.hasAttribute("disablehistory")) {
          this.setAttribute("disablehistory", true);
        }
      ]]>
      </constructor>
    </implementation>
  </binding>

</bindings>
